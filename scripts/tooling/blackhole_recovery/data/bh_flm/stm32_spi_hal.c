/*
 * Copyright (c) 2025 Tenstorrent AI ULC
 * SPDX-License-Identifier: Apache-2.0
 */

#include "spi_hal.h"
#include "stm32g0xx_ll_gpio.h"
#include "stm32g0xx.h"
#include "stm32g0xx_ll_system.h"
#include "stm32g0xx_ll_rcc.h"
#include "stm32g0xx_ll_bus.h"
#include "stm32g0xx_ll_utils.h"
#include "stm32g0xx_ll_spi.h"

/*
 * This file implements the HAL interface for the STM32 SPI peripheral.
 * It includes initialization, deinit and data transfer functions.
 */

/*
 * Note that GCC has some *fun* restrictions when compiling for Cortex-M0+, namely
 * that PLT tables are not supported. This means that we effectively can't call
 * functions in other files directly, only via function pointer.
 * To keep things simple, this implementation is just baremetal.
 */

/* Generated by STM32CubeMX */
static void SystemClock_Config(void)
{
	LL_FLASH_SetLatency(LL_FLASH_LATENCY_2);
	while (LL_FLASH_GetLatency() != LL_FLASH_LATENCY_2) {
	}

	/* HSI configuration and activation */
	LL_RCC_HSI_Enable();
	while (LL_RCC_HSI_IsReady() != 1) {
	}

	/* Main PLL configuration and activation */
	LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI, LL_RCC_PLLM_DIV_1, 8, LL_RCC_PLLR_DIV_2);
	LL_RCC_PLL_Enable();
	LL_RCC_PLL_EnableDomain_SYS();
	while (LL_RCC_PLL_IsReady() != 1) {
	}

	/* Set AHB prescaler*/
	LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);

	/* Sysclk activation on the main PLL */
	LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
	while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL) {
	}

	/* Set APB1 prescaler*/
	LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_1);
	/* Configure the SysTick to have interrupt in 1ms time base */
	SysTick->LOAD = (uint32_t)((64000) - 1UL); /* set reload register */
	SysTick->VAL = 0UL;                        /* Load the SysTick Counter Value */
	SysTick->CTRL =
		SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk; /* Enable the Systick Timer */
}

#ifdef USE_SPI1
static void SPI1_GPIO_INIT(void)
{
	/* GPIO Ports Clock Enable */
	LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOA);
	LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOB);
	LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOC);

	/**/
	LL_GPIO_ResetOutputPin(GPIOC, LL_GPIO_PIN_7);

	/**/
	LL_GPIO_ResetOutputPin(GPIOB, LL_GPIO_PIN_5);

	/* PA4- NSS */
	LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_4, LL_GPIO_MODE_ALTERNATE);
	LL_GPIO_SetPinSpeed(GPIOA, LL_GPIO_PIN_4, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOA, LL_GPIO_PIN_4, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOA, LL_GPIO_PIN_4, LL_GPIO_PULL_UP);
	LL_GPIO_SetAFPin_0_7(GPIOA, LL_GPIO_PIN_4, LL_GPIO_AF_0);

	/* PC7- SPI RST */
	LL_GPIO_SetPinMode(GPIOC, LL_GPIO_PIN_7, LL_GPIO_MODE_OUTPUT);
	LL_GPIO_SetPinSpeed(GPIOC, LL_GPIO_PIN_7, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOC, LL_GPIO_PIN_7, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOC, LL_GPIO_PIN_7, LL_GPIO_PULL_NO);

	/* PA11- MISO */
	LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_11, LL_GPIO_MODE_ALTERNATE);
	LL_GPIO_SetPinSpeed(GPIOA, LL_GPIO_PIN_11, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOA, LL_GPIO_PIN_11, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOA, LL_GPIO_PIN_11, LL_GPIO_PULL_DOWN);
	LL_GPIO_SetAFPin_8_15(GPIOA, LL_GPIO_PIN_11, LL_GPIO_AF_0);

	/* PA12- MOSI */
	LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_12, LL_GPIO_MODE_ALTERNATE);
	LL_GPIO_SetPinSpeed(GPIOA, LL_GPIO_PIN_12, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOA, LL_GPIO_PIN_12, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOA, LL_GPIO_PIN_12, LL_GPIO_PULL_DOWN);
	LL_GPIO_SetAFPin_8_15(GPIOA, LL_GPIO_PIN_12, LL_GPIO_AF_0);

	/* PB3- SCK */
	LL_GPIO_SetPinMode(GPIOB, LL_GPIO_PIN_3, LL_GPIO_MODE_ALTERNATE);
	LL_GPIO_SetPinSpeed(GPIOB, LL_GPIO_PIN_3, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_3, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOB, LL_GPIO_PIN_3, LL_GPIO_PULL_UP);
	LL_GPIO_SetAFPin_0_7(GPIOB, LL_GPIO_PIN_3, LL_GPIO_AF_0);

	/* PB5- SPI MUX */
	LL_GPIO_SetPinMode(GPIOB, LL_GPIO_PIN_5, LL_GPIO_MODE_OUTPUT);
	LL_GPIO_SetPinSpeed(GPIOB, LL_GPIO_PIN_5, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_5, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOB, LL_GPIO_PIN_5, LL_GPIO_PULL_NO);
}
#elif defined(USE_SPI_COMBO)

static void SPI_COMBO_GPIO_INIT(void)
{
	/* GPIO Ports Clock Enable */
	LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOA);
	LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOB);
	LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOC);

	/**/
	LL_GPIO_ResetOutputPin(GPIOC, LL_GPIO_PIN_8);

	/**/
	LL_GPIO_ResetOutputPin(GPIOB, LL_GPIO_PIN_6);

	/* PB12- NSS */
	LL_GPIO_SetPinMode(GPIOB, LL_GPIO_PIN_12, LL_GPIO_MODE_ALTERNATE);
	LL_GPIO_SetPinSpeed(GPIOB, LL_GPIO_PIN_12, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_12, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOB, LL_GPIO_PIN_12, LL_GPIO_PULL_UP);
	LL_GPIO_SetAFPin_8_15(GPIOB, LL_GPIO_PIN_12, LL_GPIO_AF_0);

	/* PC8- SPI RST */
	LL_GPIO_SetPinMode(GPIOC, LL_GPIO_PIN_8, LL_GPIO_MODE_OUTPUT);
	LL_GPIO_SetPinSpeed(GPIOC, LL_GPIO_PIN_8, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOC, LL_GPIO_PIN_8, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOC, LL_GPIO_PIN_8, LL_GPIO_PULL_NO);

	/* PC2- MISO */
	LL_GPIO_SetPinMode(GPIOC, LL_GPIO_PIN_2, LL_GPIO_MODE_ALTERNATE);
	LL_GPIO_SetPinSpeed(GPIOC, LL_GPIO_PIN_2, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOC, LL_GPIO_PIN_2, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOC, LL_GPIO_PIN_2, LL_GPIO_PULL_DOWN);
	LL_GPIO_SetAFPin_0_7(GPIOC, LL_GPIO_PIN_2, LL_GPIO_AF_1);

	/* PC3- MOSI */
	LL_GPIO_SetPinMode(GPIOC, LL_GPIO_PIN_3, LL_GPIO_MODE_ALTERNATE);
	LL_GPIO_SetPinSpeed(GPIOC, LL_GPIO_PIN_3, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOC, LL_GPIO_PIN_3, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOC, LL_GPIO_PIN_3, LL_GPIO_PULL_DOWN);
	LL_GPIO_SetAFPin_0_7(GPIOC, LL_GPIO_PIN_3, LL_GPIO_AF_1);

	/*
	 * PA5 is muxed to SPI1_SCLK due an issue with P300 board design.
	 * We attempt to work around this by transferring on SPI1 and SPI2 at the
	 * same time. This is sketchy from a timing perspective, but it works.
	 */
	/* PA5- SCK */
	LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_5, LL_GPIO_MODE_ALTERNATE);
	LL_GPIO_SetPinSpeed(GPIOA, LL_GPIO_PIN_5, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOA, LL_GPIO_PIN_5, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOA, LL_GPIO_PIN_5, LL_GPIO_PULL_UP);
	LL_GPIO_SetAFPin_0_7(GPIOA, LL_GPIO_PIN_5, LL_GPIO_AF_0);

	/* PB10- not routed anywhere, we just mux SPI2_SCLK to make the peripheral work */
	LL_GPIO_SetPinMode(GPIOB, LL_GPIO_PIN_10, LL_GPIO_MODE_ALTERNATE);
	LL_GPIO_SetPinSpeed(GPIOB, LL_GPIO_PIN_10, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_10, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOB, LL_GPIO_PIN_10, LL_GPIO_PULL_UP);
	LL_GPIO_SetAFPin_8_15(GPIOB, LL_GPIO_PIN_10, LL_GPIO_AF_5);

	/* PB6- SPI MUX */
	LL_GPIO_SetPinMode(GPIOB, LL_GPIO_PIN_6, LL_GPIO_MODE_OUTPUT);
	LL_GPIO_SetPinSpeed(GPIOB, LL_GPIO_PIN_6, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_6, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOB, LL_GPIO_PIN_6, LL_GPIO_PULL_NO);
}
#endif

/**
 * @brief  This function provides accurate delay (in milliseconds) based
 *         on SysTick counter flag
 * @note   When a RTOS is used, it is recommended to avoid using blocking delay
 *         and use rather osDelay service.
 * @note   To respect 1ms timebase, user should call @ref LL_Init1msTick function which
 *         will configure Systick to 1ms
 * @param  Delay specifies the delay time length, in milliseconds.
 * @retval None
 */
void LL_mDelay(uint32_t Delay)
{
	__IO uint32_t tmp = SysTick->CTRL; /* Clear the COUNTFLAG first */
	uint32_t tmpDelay;                 /* MISRAC2012-Rule-17.8 */
	/* Add this code to indicate that local variable is not used */
	((void)tmp);
	tmpDelay = Delay;
	/* Add a period to guaranty minimum wait */
	if (tmpDelay < LL_MAX_DELAY) {
		tmpDelay++;
	}

	while (tmpDelay != 0U) {
		if ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) != 0U) {
			tmpDelay--;
		}
	}
}

void stm32_spi_periph_init(SPI_TypeDef *spi)
{
	/*
	 * System core clock (and PCLK) are running at 64 MHz.
	 * Clock SPI at 8 MHz.
	 */
	LL_SPI_SetTransferDirection(spi, LL_SPI_FULL_DUPLEX);
	LL_SPI_SetMode(spi, LL_SPI_MODE_MASTER);
	LL_SPI_SetDataWidth(spi, LL_SPI_DATAWIDTH_8BIT);
	LL_SPI_SetClockPolarity(spi, LL_SPI_POLARITY_HIGH);
	LL_SPI_SetClockPhase(spi, LL_SPI_PHASE_2EDGE);
	LL_SPI_SetNSSMode(spi, LL_SPI_NSS_HARD_OUTPUT);
#ifdef USE_SPI_COMBO
	/* Reduce frequency to 250 KHz, otherwise the combo workaround will fail.
	 * 500 KHz also appears to work but we keep frequency low to be safe
	 */
	LL_SPI_SetBaudRatePrescaler(spi, LL_SPI_BAUDRATEPRESCALER_DIV256);
#else
	/* 8 MHz works fine for general use */
	LL_SPI_SetBaudRatePrescaler(spi, LL_SPI_BAUDRATEPRESCALER_DIV16);
#endif
	LL_SPI_SetTransferBitOrder(spi, LL_SPI_MSB_FIRST);
	LL_SPI_DisableCRC(spi);
	LL_SPI_SetStandard(spi, LL_SPI_PROTOCOL_MOTOROLA);
	LL_SPI_DisableNSSPulseMgt(spi);
	/* Set RX FIFO level to 8 bits (1/4) */
	LL_SPI_SetRxFIFOThreshold(spi, LL_SPI_RX_FIFO_TH_QUARTER);
	/* Disable interrupts */
	LL_SPI_DisableIT_ERR(spi);
	LL_SPI_DisableIT_RXNE(spi);
	LL_SPI_DisableIT_TXE(spi);
	/* Disable DMA */
	LL_SPI_DisableDMAReq_RX(spi);
	LL_SPI_DisableDMAReq_TX(spi);
}

/*
 * Init the SPI peripheral, including setting up GPIOs and clocks.
 * @return 0 on success, -1 on failure.
 */
int stm32_spi_init(void)
{
	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_SYSCFG);
	LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);

	/** Disable the internal Pull-Up in Dead Battery pins of UCPD peripheral */
	LL_SYSCFG_DisableDBATT(LL_SYSCFG_UCPD1_STROBE | LL_SYSCFG_UCPD2_STROBE);
	/* Setup system clock */
	SystemClock_Config();

	/* Peripheral clock enable */
#ifdef USE_SPI1
	LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_SPI1);
	LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_SPI1);
	LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_SPI1);
	/* Initialize GPIOs */
	SPI1_GPIO_INIT();
	stm32_spi_periph_init(SPI1);

	/* Set SPI MUX to high so we have control over the SPI pins */
	LL_GPIO_SetOutputPin(GPIOB, LL_GPIO_PIN_5);

	/* Pulse RST line to reset SPI */
	LL_GPIO_ResetOutputPin(GPIOC, LL_GPIO_PIN_7);
	LL_mDelay(1); /* Wait for 1 ms */
	LL_GPIO_SetOutputPin(GPIOC, LL_GPIO_PIN_7);
#elif defined(USE_SPI_COMBO)
	/* Because the board design connects SPI1_SCLK to the SPI, we need
	 * to init both SPI1 and SPI2
	 */
	LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_SPI1);
	LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_SPI1);
	LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_SPI1);
	LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_SPI2);
	LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_SPI2);
	LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_SPI2);
	/* Initialize GPIOs- just need SPI2 GPIOs here, SPI1 SCLK will be muxed
	 * in SPI_COMBO_GPIO_INIT()
	 */
	SPI_COMBO_GPIO_INIT();
	stm32_spi_periph_init(SPI1);
	stm32_spi_periph_init(SPI2);

	/* Set SPI MUX to high so we have control over the SPI pins */
	LL_GPIO_SetOutputPin(GPIOB, LL_GPIO_PIN_6);

	/* Pulse RST line to reset SPI */
	LL_GPIO_ResetOutputPin(GPIOC, LL_GPIO_PIN_8);
	LL_mDelay(1); /* Wait for 1 ms */
	LL_GPIO_SetOutputPin(GPIOC, LL_GPIO_PIN_8);
#endif
	return 0;
}

/*
 * Deinitialize the SPI peripheral.
 * @return 0 on success, -1 on failure.
 */
int stm32_spi_deinit(void)
{
#if defined(USE_SPI1)
	/* Force reset of SPI clock */
	LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_SPI1);
	/* Release reset of SPI clock */
	LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_SPI1);
#elif defined(USE_SPI_COMBO)
	/* Once again, we need to reset SPI1 and SPI2 because of the board issue */
	LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_SPI1);
	/* Release reset of SPI clock */
	LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_SPI1);
	/* Force reset of SPI clock */
	LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_SPI2);
	/* Release reset of SPI clock */
	LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_SPI2);
#endif
	return 0;
}

#ifdef USE_SPI1
#define SPI_DEV SPI1
#elif defined(USE_SPI_COMBO)
#define SPI_DEV SPI2
#endif

/*
 * Transfer data over SPI.
 * @param bufs: Array of buffers containing data to transmit and receive.
 * @param cnt: Number of buffers in the array.
 * @return 0 on success, -1 on failure.
 */
int stm32_spi_transfer(struct spi_buf *bufs, uint8_t cnt)
{
	uint32_t tx_off, rx_off;
	LL_SPI_Enable(SPI_DEV);
#ifdef USE_SPI_COMBO
	LL_SPI_Enable(SPI1); /* Enable SPI1 as well for the combo mode */
#endif
	/* Just use a polling transfer here */
	for (uint8_t buf_idx = 0; buf_idx < cnt; buf_idx++) {
		tx_off = 0, rx_off = 0;
		while (tx_off < bufs[buf_idx].len || rx_off < bufs[buf_idx].len) {
			if (LL_SPI_IsActiveFlag_TXE(SPI_DEV) && tx_off < bufs[buf_idx].len) {
				/* Write bytes to TX FIFO */
				if (bufs[buf_idx].tx_buf) {
					LL_SPI_TransmitData8(SPI_DEV, bufs[buf_idx].tx_buf[tx_off]);
				} else {
					LL_SPI_TransmitData8(SPI_DEV,
							     0xFF); /* If no TX buffer, send 0xFF */
				}
#ifdef USE_SPI_COMBO
				/*
				 * This is the core of the hack for SPI_COMBO mode- the board
				 * routes SPI1_SCLK with SPI2_MOSI/SPI2_MISO. To induce clocks
				 * on SPI1 at *roughly* the same time as SPI2, we transmit 0xFF
				 * on SPI1 while transmitting on SPI2.
				 * This will definitely break at higher frequencies, but
				 * it should work at 8 MHz.
				 */
				LL_SPI_TransmitData8(SPI1, 0xFF);
#endif
				tx_off++;
			}
			if (LL_SPI_IsActiveFlag_RXNE(SPI_DEV) && rx_off < bufs[buf_idx].len) {
				/* Read bytes from RX FIFO */
				if (bufs[buf_idx].rx_buf) {
					bufs[buf_idx].rx_buf[rx_off] = LL_SPI_ReceiveData8(SPI_DEV);
				} else {
					LL_SPI_ReceiveData8(
						SPI_DEV); /* If no RX buffer, discard data */
				}
				rx_off++;
			}
#ifdef USE_SPI_COMBO
			if (LL_SPI_IsActiveFlag_RXNE(SPI1)) {
				/* Drain the SPI1 RX FIFO */
				LL_SPI_ReceiveData8(SPI1);
			}
#endif
		}
	}

	while (LL_SPI_IsActiveFlag_BSY(SPI_DEV)) {
		/* Wait for BSY flag to clear, indicating transfer is done. */
	}
	LL_SPI_Disable(SPI_DEV);
#ifdef USE_SPI_COMBO
	LL_SPI_Disable(SPI1); /* Disable SPI1 as well for the combo mode */
#endif
	return 0;
}
